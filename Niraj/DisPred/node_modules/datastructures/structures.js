/* ===================================================
 * Hash.js v0.01
 * https://github.com/rranauro/boxspringjs
 * ===================================================
 * Copyright 2013 Incite Advisors, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================== */
/*jslint newcap: false, node: true, vars: true, white: true, nomen: true  */

var Hash = function(init) {
	var item
	, newItem;
	this._attributes = {};
	this._original = {};
	
	for (item in init) {
		if (init.hasOwnProperty(item)) {
			this._attributes[item] = this._original[item] = init[item];
		}
	}
	return this;		
};

Hash.prototype.get = function (name) {			
	return this._attributes && this._attributes[name];
};
Hash.prototype.lookup = Hash.prototype.get;
Hash.prototype.find = Hash.prototype.get;

Hash.prototype.contains = function (name) {
	return (typeof this.get(name) !== 'undefined');
};

Hash.prototype.attributes = function (v) {
	if (v) {
		this._attributes = v;
	}
	return this._attributes;
};
Hash.prototype.post = Hash.prototype.attributes;

Hash.prototype.getLength = function () {
	var k
	, count = 0;

	for (k in this._attributes) {
		if (this._attributes.hasOwnProperty(k)) {
			count += 1;				
		}
	}
	return count;
};

// What it does: Remove an item from the Hash
Hash.prototype.remove = function (name) {
	if (this._attributes[name]) {
		delete this._attributes[name];
	}
	return this;
};
// What it does: Return the Hash as an array so it can be used as an argument to map/reduce
Hash.prototype.each = function () {
	var objectArray = []
	, obj;

	for (obj in this._attributes) {
		if (this._attributes.hasOwnProperty(obj)) {
			objectArray.push([obj, this._attributes[obj]]);				
		}
	}
	return objectArray;
};

Hash.prototype.keys = function () {
	var keyArray = []
	, obj;

	for (obj in this._attributes) {
		if (this._attributes.hasOwnProperty(obj)) {
			keyArray.push(obj);				
		}
	}
	return keyArray;
};

Hash.prototype.first = function () {
	return(this.get(this.keys()[0]));		
};

// What it does: Bulk update the properties of the Hash
Hash.prototype.update = function (properties) {
	var property;
	
	for (property in properties) {
		if (properties.hasOwnProperty(property)) {
			this.set(property, properties[property]);
		}
	}
	return this;		
};

Hash.prototype.set = function (name, value) {
	var property;
	
	if (typeof name === 'object') {
		for (property in name) {
			if (name.hasOwnProperty(property)) {
				this.set(property, name[property]);
			}
		}			
	} else {
		this._attributes[name] = value;			
	}
	return this;
};
Hash.prototype.store = Hash.prototype.set;

// What it does: Returns an object containing only the selected items. args can be an Array of strings
// or separate argument strings
Hash.prototype.pick = function (args) {
	var i
	, list = []
	, target = {};
	
	// accepts arguments as either array of items to pick, or argument list of items
	if (typeof args === 'string') {
		// convert the arguments list to an array
		for (i=0; i < arguments.length; i += 1) {
			list.push(arguments[i]);
		}
	} else {
		// or, just use as is
		list = args;
	}
	// iterate over the arguments to pick up the items requested
	for (i=0; i < list.length; i += 1) {
		target[list[i]] = this.get(list[i]);
	}
	return target;
};

// What it does: Returns the object values to its original state
Hash.prototype.restore = function () {
	var item;
	
	for (item in this._attributes) {
		if (this._attributes.hasOwnProperty(item)) {
			this._attributes[item] = undefined;
		}
	}
	for (item in this._original) {
		if (this._original.hasOwnProperty(item)) {
			this._attributes[item] = this._original[item];
		}
	}
	return this;
};

Hash.prototype.empty = function () {
	return this.post({});
};

exports.Hash = Hash;

var Tree = function(obj) {
	var items;
	
	for (items in obj) {
		if (obj.hasOwnProperty(items)) {
			this[items] = obj[items];				
		}
	}
	this.child = undefined;
	this.sibling = undefined;
	this.owner = undefined;
	return this;
};


Tree.prototype.addChild = function (obj) {
	return this.insertChild(new Tree(obj));
};

Tree.prototype.firstChild = function () {
	return this.child;
};

Tree.prototype.nextSibling = function () {
	return this.sibling;
};
Tree.prototype.lastSibling = function () {
	var sib = ((this && this.sibling) || this)
	, LIMIT = 1000000
	, counter = 0;
	
	while ((sib && sib.sibling) && counter < LIMIT) {
		sib = sib.sibling;
	}
	if (counter === LIMIT) {
		throw new Error('Tree: cycle encountered');
	}
	return sib;
};
Tree.prototype.lastChild = function () {
	return this.firstChild() && this.firstChild().lastSibling();
};
Tree.prototype.parent = function () {
	return this.owner;
};
Tree.prototype.firstSibling = function () {
	return this.parent() && this.parent().firstChild();		
};
Tree.prototype.previousSibling = function () {
	var predecessor = this.firstSibling();
	while (predecessor && predecessor.sibling && predecessor.sibling !== this) {
		predecessor = predecessor.sibling;
	}
	return predecessor;
};
Tree.prototype.grandParent = function () {
	return (this.parent() && this.parent().parent());
};
// What it does: fetches the last sibling from the objects children and inserts child at the end.
Tree.prototype.insertChild = function (child) {
	var lastChild = this.lastChild();

	// case 1: no first child, just add the child
	if (!this.firstChild()) {
		child.sibling = undefined;
		child.owner = undefined;
		return this.insertFirstChild(child);
	}
	// case 2: fetch last child and add this to the end
	try {
		lastChild.sibling = child;
		child.owner = lastChild.owner;
		child.sibling = undefined;				
	} catch (e) {
		throw new Error('Tree.insertChild(): lastChild wrong!');
	}
	return this;
};

// insert an element as the first child of a parent; previous first child is sibling of new
Tree.prototype.insertFirstChild = function (child) {
	if (child) {
		if (this && this.child) {
			child.sibling = this.child;
		} else {
			child.sibling = undefined;					
		}
		this.child = child;
		child.owner = this;
	}
	return this;				
};

// insert an element as a sibling of this element
Tree.prototype.spliceIn = function (sib) {
	if (sib) {
		sib.sibling = this.sibling;
		this.sibling = sib;
		sib.owner = this.owner;
	}
	return sib;
};

// remove a sibling from a Tree of siblings
Tree.prototype.spliceOut = function () {
	var location = this && this.parent() && this.parent().firstChild()
	, owner = this && this.parent();

	// only child
	if (this === location && !this.sibling) {
		this.owner.child = undefined;
		this.owner = undefined;
		return undefined;
	}
	// first child with siblings
	if (this === location && this.sibling) {
		this.owner.child = this.sibling;
		this.owner = undefined;
		this.sibling = undefined;
		return owner.firstChild();
	}
	// middle child or end child
	while (location && location.sibling && location.sibling !== this) { 
		location = location.sibling; 
	}
	location.sibling = this.sibling;
	this.owner = undefined;
	this.sibling = undefined;
	return location;
};

Tree.prototype.siblings = function (it) {
	var result = [] 
	, next = (this && this.owner && this.owner.child)
	, iterator = (((typeof it === 'function') && it) || function () { return true; });

	while (next) {
		if (iterator(next) === true) {
			result.push(next);						
		}
		next = next.sibling;					
	}
	return result;
};	

Tree.prototype.each = function () {
	var result = [];

	this.walk(function() {
		result.push(this);
	});
	return result;
};

Tree.prototype.walk = function(fn) {			
	if (typeof fn !== 'function') {
		throw new Error('Tree.walk(): You must supply a function to the Tree walk method.');				
	}
	// visit this node
	fn.call(this, this);
	if (this && this.child) {
		// its child
		this.child.walk(fn);
	}
	if (this && this.sibling) {
		this.sibling.walk(fn);
	}
};

Tree.prototype.find = function(id, fn) {
	var local = this
		, found;

	// the empty argument Tree returns the id of self	
	if (arguments.length === 0) {
		return this.id;
	}

	this.walk(function(item) {
		if (item.id === id) {
			if (fn && typeof fn === 'function') {
				fn.call(local, item);
			} else {
				found = item;
			}
		}
	});
	return found;
};

exports.Tree = Tree;

var Queue = function() {	
	this.Pending = [];
	this.Running = [];
	this.cleared = false;
	this.hold = false;
	this.afterFunc = function () { return; };
	this.afterFuncArgs = [];
	this.depth = 1;
	return this;		
};

Queue.prototype.submit = function (func) {
	var i
	, args = [];
	// any arguments to submit after func are the arguments to func. Conver them to array.
	for (i=1; i < arguments.length; i += 1) {
		args.push(arguments[i]);
	}
	// the queue will dequeue func with argument args
	this.Pending.push({ 'func': func, 'args': args });
	return this;		
};

// What it does: Called by the application to start the queue running. 
// cycle method continuously calls it while there are still jobs pending.
Queue.prototype.run = function () {
	var nextJob = {};

	if (this.hold === true) { return; }
	if ((this.Pending.length > 0) // remaining jobs
			&& (this.Running.length < this.depth)) { // more capacity available
		this.Running.push({});
		this.cycle();
		nextJob = this.Pending.shift();
		try {
			_.wait(1/10, function() {
				nextJob.func.apply(this, nextJob.args);
			}, this);
		} catch (e) {
			throw new Error(_.sprintf('[ queue/run ]: %s', e));
		}
	} 
	return this;
};

// What it does: We need some space between the last dequeue and the next attempt to run a job; or else
// we can get a race.
Queue.prototype.cycle = function () {
	var local = this;
	setTimeout(function () {
		local.run();
		if (!local.cleared && (local.Pending.length > 0 || local.Running.length > 0)) { 
			local.cycle(); 
		}
	}, 100);
};
// What this does: Called by the application when the job finishes. If the queue is empty, 
// run the 'afterFunc', if one was supplied.
Queue.prototype.finish = function () {
	this.Running.pop();
	if (this.Pending.length === 0 && this.Running.length === 0) {
		this.afterFunc.apply(this.afterFuncContext, this.afterFuncArgs);
	}
	return this;		
};

Queue.prototype.max = function (depth) {
	if (depth) {
		this.depth = parseInt(depth, 10);
	}
	return this;		
};

Queue.prototype.after = function (func, args, context) {
	if (func && typeof func === 'function') {
		this.afterFunc = func;
		this.afterFuncArgs = args;
		this.afterFuncContext = context || this;
	}
	return this;
};

Queue.prototype.suspend = function () {
	this.hold = true;
	return this;
};

Queue.prototype.resume = function () {
	this.hold = false;
	return this;
};

Queue.prototype.pending = function () {
	return this.Pending.length;
};

Queue.prototype.running = function () {
	return this.Running.length;
};

Queue.prototype.clear = function () {
	while (this.Pending.length > 0) {
		this.Pending.pop();
	}
	this.cleared = true;
	this.afterFunc.apply(this.afterFuncContext, this.afterFuncArgs);
	return this;		
};

exports.Queue = Queue;
